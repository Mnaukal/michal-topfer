import Head from 'next/head'

<Head>
  <title>CviÄenÃ­ NPRG030 â€“ ProgramovÃ¡nÃ­ 1 â€“ Michal TÃ¶pfer</title>
</Head>

# Algoritmizace â€“ 9. cviÄenÃ­

## Fibonacci

NapiÅ¡te funkci pro vÃ½poÄet $n$-tÃ©ho prvku Fibonacciho posloupnosti (definici si mÅ¯Å¾ete pÅ™ipomenout na [Wikipedii](https://cs.wikipedia.org/wiki/Fibonacciho_posloupnost)):

Zkuste navrhnou dvÄ› rÅ¯znÃ¡ Å™eÅ¡enÃ­:

* rekurzivnÃ­,
* iterativnÃ­ (bez rekurze).

SpoleÄnÄ› si pak porovnÃ¡me jejich efektivitu.

### ğŸ¦‰ *Bonus:* Cache pro mezivÃ½sledky

U rekurzivnÃ­ho Å™eÅ¡enÃ­ si uklÃ¡dejte uÅ¾ spoÄÃ­tanÃ© hodnoty, abyste je nemuseli poÄÃ­tat znovu.

## HanojskÃ© vÄ›Å¾e

Dle legendy existuje v Asii chrÃ¡m, v nÄ›mÅ¾ kaÅ¾dÃ½ den v poledne mniÅ¡i slavnostnÄ› pÅ™emÃ­stÃ­ jeden z 64 zlatÃ½ch kotouÄÅ¯. Jakmile bude pÅ™emÃ­stÄ›na celÃ¡ "vÄ›Å¾", nastane konec svÄ›ta. SpoÄÃ­tejte, za jak dlouho k tomu mÅ¯Å¾e dojÃ­t.

JinÃ½mi slovy, spoÄÃ­tejte kolik tahÅ¯ potÅ™ebuje nÃ¡Å¡ (rekurzivnÃ­) algoritmus na pÅ™emÃ­stÄ›nÃ­ $n$ kotouÄÅ¯?

Algoritmus z pÅ™ednÃ¡Å¡ky:

```py
def hanoj(pocet, odkud, kam, rezervni):
    if pocet == 1:
        print(f"PresuÅˆ kotouÄ z vÄ›Å¾e {odkud} na vÄ›Å¾ {kam}")
    else:
        hanoj(pocet - 1, odkud, rezervni, kam)
        hanoj(1, odkud, kam, rezervni)
        hanoj(pocet - 1, rezervni, kam, odkud)
```

### NÃ¡povÄ›da

OznaÄte poÄet tahÅ¯ pro $n$ kotouÄÅ¯ tÅ™eba $T(n)$. To odpovÃ­dÃ¡ ÄasovÃ© sloÅ¾itosti volÃ¡nÃ­ funkce `hanoj(n, ...)`.
Rozmyslete si, kolikrÃ¡t rekurzivnÄ› volÃ¡te funkci `hanoj` a s jakÃ½m poÄtem kotouÄÅ¯. Vztah pro $T(n)$ se dÃ¡ na zÃ¡kladÄ› toho vyjÃ¡dÅ™it jako souÄet nÄ›kolika hodnot $T$ pro ÄÃ­sla menÅ¡Ã­ neÅ¾ $n$. SamozÅ™ejmÄ› nesmÃ­te zapomenout poÄÃ­tat hodnotu $T(1)$ zvlÃ¡Å¡Å¥ (ukonÄenÃ­ rekurze).

Pak mÅ¯Å¾ete zkusit dopoÄÃ­tat hodnotu $T(n)$ pro malÃ¡ $n$ a zkusit odhadnout, jak to vyjde obecnÄ›.

## GenerovÃ¡nÃ­ permutacÃ­

NapiÅ¡te funkci, kterÃ¡ dostane seznam a vygeneruje vÅ¡echny permutace prvkÅ¯ v tomto seznamu. PÅ™edpoklÃ¡dejte, Å¾e v zadanÃ©m seznamu se prvky neopakujÃ­.

NapÅ™Ã­klad volÃ¡nÃ­ `permutations([1, 2, 3])` vrÃ¡tÃ­ 6 moÅ¾nÃ½ch permutacÃ­: `[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]`. Je na vÃ¡s, jestli funkce bude vracet seznam vÅ¡ech permutacÃ­ (tedy seznam seznamÅ¯) nebo ji napÃ­Å¡ete jako generÃ¡tor.

## GenerovÃ¡nÃ­ podmnoÅ¾in

NapiÅ¡te funkci, kterÃ¡ dostane seznam a vygeneruje vÅ¡echny podmnoÅ¾iny tohoto seznamu. PÅ™edpoklÃ¡dejte, Å¾e v zadanÃ©m seznamu se prvky neopakujÃ­.

NapÅ™Ã­klad volÃ¡nÃ­ `subsets([0, 1])` vrÃ¡tÃ­ 4 moÅ¾nÃ© podmnoÅ¾iny: `[], [0], [1], [0, 1]`. Je na vÃ¡s, jestli funkce bude vracet seznam vÅ¡ech podmnoÅ¾in (tedy seznam seznamÅ¯) nebo ji napÃ­Å¡ete jako generÃ¡tor.

### NÃ¡povÄ›da

UvÄ›domte si, Å¾e podmnoÅ¾ina vznikne tak, Å¾e do nÃ­ kaÅ¾dÃ½ prvek z pÅ¯vodnÃ­ mnoÅ¾iny buÄ dÃ¡me, nebo nedÃ¡me. PodmnoÅ¾iny seznamu s $n$ prvky tedy odpovÃ­dajÃ­ vÅ¡em $n$-prvkovÃ½m posloupnostem `True` a `False`, tedy i vÅ¡em $n$-cifernÃ½m ÄÃ­slÅ¯m ve dvojkovÃ© soustavÄ› (nevadÃ­ nuly na zaÄÃ¡tku).

### ğŸ¦‰ *Bonus:* RostoucÃ­ posloupnosti

Rozmyslete si, jak se dÃ¡ generovÃ¡nÃ­ podmnoÅ¾in vyuÅ¾Ã­t pro generovÃ¡nÃ­ vÅ¡ech rostoucÃ­ch posloupnostÃ­ tvoÅ™enÃ½ch z ÄÃ­sel $1, 2, \dots, N$.
